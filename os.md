# CS 4410

这是CS 4410的预习笔记。本课程讨论的问题是操作系统。

操作系统是一个非常特殊的、最低级的软件。它的目标是让多个程序能够一起执行、让多个程序分享内存或与输入输出设备交互等等。操作系统通过*虚拟化*完成这些任务，即提供给程序一系列虚拟的资源，自己把这些虚拟资源对应到实际存在的物理资源，从而方便地让一套硬件上能运行多个程序。因此，操作系统有时又称虚拟机。通过虚拟化资源，操作系统能让程序并行执行。通过建立一套文件系统，操作系统能有效管理内存。通过建立网络通信，操作系统能够让分布式系统成为可能。

为了方便程序利用操作系统的资源，操作系统会提供一系列标准接口，这些接口称为**系统调用**。操作系统还会通过虚拟化CPU和虚拟化内存，定下程序执行的规则，综合管理其拥有的资源。

## 第1章 虚拟化

本章我们主要讨论处理器和内存的虚拟化。

### 1.1 处理器虚拟化

#### 1.1.1 进程

一个正在执行的程序称为**进程**。每个进程都有其内存，它们都是由地址空间指明的。进程需要被创建、消灭、等待和控制。一套硬件也可以运行大量的进程，而操作系统通过虚拟化处理器实现这个功能。时间分享（即某个进程运行一会儿，再让另一个进程运行一会儿，再回到第一个进程的策略）和空间分享（资源存储多份）是主要的虚拟化方式，而进程的调度策略是操作系统中实现的核心内容。

操作系统在启动进程时，首先会给进程分配地址空间，之后它会把存在磁盘上的程序导入内存。然后它会建立进程的调用栈和内存堆，在必要时通过文件系统等打开输入输出，并把控制权转交给新创建的进程，让它从起始位置开始运行。在进程运行时，进程可以在运行、待命、受阻三个状态间切换。当进程完成时，操作系统会负责把程序的调用栈清除（堆不一定），关闭输入输出。操作系统会通过维护进程列来管理进程。

#### 附录 在Unix操作系统中创建和关闭进程

Unix系统中创建进程的系统调用是fork和exec。fork复制了一个当前的进程，但还没开始执行任何事务，而exec则把另一个程序的代码拷到当前进程来执行。把创建进程的命令分成两部分是为了方便在fork之后、exec之前，可以重定向执行的目标地。wait系统调用则会确保父进程在子进程结束之后再结束。

Unix系统中关闭进程的命令是kill。kill通过发送某些信号的方式让进程终止。使用kill时要多加小心，切勿把有用的进程也关闭了。

Unix系统中管理进程的方式是信号。常用的信号有2号（SIGINT），9号（SIGKILL），14号（SIGALARM）等等。信号与系统调用最大的不同是，系统调用由进程发出，与硬件有关，由操作系统处理，而信号由操作系统发出，与硬件无关，是为了控制进程继续执行与否，由用户和软件处理。

#### 1.1.2 有限直接执行

进程是通过“有限直接执行”的方式执行的。大量的行动不能让进程自己执行，比如输入输出、访问内存等。为此，处理器中进程运行的模式应有两种：用户模式和内核模式。比如，用户模式中无法输入输出，而只有内核模式可以。用户模式下进程想输入输出，启动或终止进程，因page fault需要永久内存，访问文件系统，或打扰其他进程时，必须进行系统调用。

系统调用绝不能像函数调用一样直接把程序跳到某处。对于任何一种系统调用，操作系统都必须特殊地指明它的trap handler，硬件就会知道当异常情况发生时自己应该干什么。操作系统启动时，会初始化这张trap表，以给出那些系统调用的特殊地址。trap表中的地址还是间接的地址（称为系统调用号），能起到保护的作用。trap表的创建和访问都只有操作系统才能完成。

系统调用时，进程会经历trap过程，以进入内核模式。为了重新返回正常执行，程序必须从trap中退出。进入trap时，处理器（硬件）会把程序的PC、调用栈寄存器等许多重要的寄存器存到一个每个进程都有的内核栈中，访问trap表，找到要做的操作。而退出trap时，这些栈中存储的值都会被返回，进程返回原运行状态。

另一个需要操作系统通过有限直接执行的方式管控的是在进程之间不断切换的操作，这是为了实现时间分享，制造同一套硬件可以运行多个进程的假象。可以期待进程定时进行系统调用，这样操作系统就可以在调用期间把该进程暂停，但这种期待对于某些危险的进程而言是不现实的（重启？）。更安全的方式是给每个进程设置一个时间限制，一旦超时进程会中断，控制权将转交给系统。

操作系统启动时，必须向硬件指明中断的handler，以处理这种情况。操作系统也必须在系统启动之前指明每个进程的时间限制。硬件应该配合处理中断，包括保存进程的状态等。然后操作系统会更改环境，即选择执行另一个进程。这种调度选择的过程我们会在下一小节中讲到。

#### 1.1.3 进程调度

进程的周转时间是指其完成时刻减去到达系统的时刻，而进程的响应时间是指其开始执行时刻减去到达系统的时刻。

基础的调度策略是先到先得(FIFO)，但当某个耗时很久的进程阻挡在其他进程之前时，系统就有卡顿（周转时间长）的问题。另一种调度策略是最快者优先(SJF)。如果所有进程同时到达，最快者优先是最优的调度策略，然而如果进程不同时到达，卡顿的问题则依然存在。策略三是最快结束者优先(STCF)，这种策略在进程不同时到达的情况下成了最优。

以上的策略是在没有时间分享的情况下讨论的。然而，时间分享给了我们更充分的调度工具。我们可以让每个进程只运行一小会儿（RR），这样所有进程都能有较短的相应时间，但周转时间会受到很大影响。每个进程可以运行的时间周期非常重要，这个周期要充分长，以允许进程有实质性动作，但为缩短响应时间也不能太长。

输入输出、系统调用等会把CPU空出来。在进程调度时，操作系统就应该在CPU空出来的时候运行其他进程，以统筹的方式提高处理器效率。

一个需要解决的重要问题是，操作系统怎么能在不运行进程，从而不知道进程运行时间的情况下完成调度呢？操作系统是通过预测进程运行时间的方法完成的。它建立了一个叫多层反馈队列(MLFQ)的启发式的数据结构。这个数据结构把进程组合进一组队列，不同的队列有不同的优先级，同一队列有相同的优先级。MLFQ有如下5个规则：（1）处理器会运行优先级最高的那个队列，（2）但每个队列中的那些进程按RR运行。队列的优先级随观察到的结果灵活变化。（3）每个进程刚进入系统时有最高的优先级。（4）如若此进程用光了属于它的那一小块时间则其优先级降低，哪怕此进程在中途离开了CPU。（5）每隔一段时间优先级全部归零。

另一种实用的进程调度策略是比例调度，即保证每个进程都占有一定比例的CPU时间。在每个时间周期内，操作系统给每个进程赋予一个权重，以*随机*方式加权选出本周期运行的进程。每个进程还可以给它们的子进程加权，且进程权重也不是一成不变的。这种方法既简单，又可以在进程数较多时保证调度的公平性。

#### 附录 Linux系统中的进程调度

现代Linux系统使用了一种称为“完全公平调度（CFS）”的进程调度方式。它的方法是测量每个进程的虚拟运行时间(vruntime)，拥有最低vruntime的进程将会被提高执行权限，这个执行权限就是著名的nice值。如果进程少则每个进程每个周期时间多，如果进程多则反之，但每个进程周期有个最低下限，这样就保证切换频繁，相对公平，同时通过设置进程切换周期下限，且设置vruntime权限，保证进程周转时间较小。

因为进程的个数可能远超千个，CFS为加快调度速度，内部的进程列按照vruntime用红黑树存储。对于输入、输出和睡眠的进程，vruntime做额外处理。

#### 拓展 多核处理器中的进程调度

多核下进程调度比单核还要困难，同样有大量的优化思路涌现出来。

思路一：单队列调度(SQMS)。所有核共用一个进程队列，每个进程运行时加锁。这样很简单，却无法适应核数目的增长，同时还无法让一个进程尽可能只在一个核上运行。为此需把一些进程移植到与用原本方法不同的核上运行，优化很困难。

思路二：多队列调度(MQMS)。每个核维护一个进程队列。这样能适应核的增长，却容易出现核负载不均衡的现象，同样需要把某些进程移植到另一个核上运行，优化也不容易。

### 1.2 内存虚拟化
